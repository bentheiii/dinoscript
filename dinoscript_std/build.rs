mod items_template;

use std::{
    collections::HashMap,
    fs::File,
    io::{BufRead, BufReader, Write},
};

use items_template::setup_items;
fn main() {
    println!("cargo::rerun-if-changed=items_template.rs");

    let replacements = setup_items().replacements;

    let template_file = BufReader::new(File::open("items_template.rs").unwrap());
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let output_file = File::create(format!("{out_dir}/items.rs")).unwrap();
    apply_template(output_file, template_file, &replacements);
}

fn apply_template(mut write: impl Write, read: impl BufRead, replacements: &HashMap<&str, String>) {
    fn get_pragma_parts(pragma: &str) -> Option<Vec<&str>> {
        pragma
            .trim()
            .strip_prefix("// pragma:")
            .map(|p| p.split_whitespace().collect())
    }
    write.write_all(b"// This file was generated by build.rs\n").unwrap();
    let mut lines = read.lines().enumerate().map(|(ln, l)| l.map(|l| (ln + 1, l)));
    while let Some((_, raw_line)) = lines.next().transpose().unwrap() {
        if let Some(parts) = get_pragma_parts(&raw_line) {
            match parts[0] {
                "replace-start" => {
                    let initial_indent = raw_line.chars().take_while(|c| c.is_whitespace()).collect::<String>();
                    let mut replace_id = None;
                    loop {
                        let (ln, raw_line) = lines.next().unwrap().unwrap();
                        if raw_line.ends_with("// pragma:replace-end") {
                            assert!(replace_id.is_some());
                            write.write_all(initial_indent.as_bytes()).unwrap();
                            write
                                .write_all(replacements[replace_id.as_deref().unwrap()].as_bytes())
                                .unwrap();
                            break;
                        }
                        if let Some(parts) = get_pragma_parts(&raw_line) {
                            match parts[0] {
                                "replace-id" => {
                                    assert!(replace_id.is_none());
                                    let (_, replace_id_line) = lines.next().unwrap().unwrap();
                                    replace_id =
                                        Some(replace_id_line.trim_matches(|c: char| !c.is_alphanumeric()).to_string());
                                }
                                "replace-with-raw" => {
                                    let (_, first_line) = lines.next().unwrap().unwrap();
                                    let first_raw_line = first_line.trim();
                                    if first_raw_line == "/*" {
                                        loop {
                                            let (_, raw_line) = lines.next().unwrap().unwrap();
                                            if raw_line.trim() == "*/" {
                                                assert_eq!(
                                                    lines.next().unwrap().unwrap().1.trim(),
                                                    "// pragma:replace-end"
                                                );
                                                break;
                                            }
                                            write.write_all(raw_line.as_bytes()).unwrap();
                                            write.write_all(b"\n").unwrap();
                                        }
                                    } else if let Some(["replace-end"]) = get_pragma_parts(first_raw_line).as_deref() {
                                    } else {
                                        panic!("Expected a comment or a replace-end pragma, got: {first_raw_line}")
                                    }
                                    break;
                                }
                                _ => {
                                    panic!("Unknown pragma inside replace: {raw_line} at line {ln}")
                                }
                            }
                        }
                    }
                }
                "skip" => {
                    let n = parts[1].parse::<usize>().unwrap();
                    for _ in 0..n {
                        lines.next().unwrap().unwrap();
                    }
                }
                "unwrap" => {
                    let (_, first_line) = lines.next().unwrap().unwrap();
                    let initial_indent = first_line.chars().take_while(|c| c.is_whitespace()).collect::<String>();
                    // we need to get everything from the first line after the parenthesis
                    let first_line_after_parenthesis =
                        first_line.chars().skip_while(|c| c != &'(').skip(1).collect::<String>();
                    write.write_all(initial_indent.as_bytes()).unwrap();
                    write.write_all(first_line_after_parenthesis.as_bytes()).unwrap();
                    loop {
                        let (_, raw_line) = lines.next().unwrap().unwrap();
                        if raw_line.chars().all(char::is_whitespace) {
                            write.write_all(b"\n").unwrap();
                            continue;
                        }
                        let without_indent = raw_line.strip_prefix(&initial_indent).unwrap();
                        let first_char = without_indent.chars().next().unwrap();
                        if first_char.is_whitespace() {
                            write.write_all(raw_line.as_bytes()).unwrap();
                            write.write_all(b"\n").unwrap();
                        } else {
                            // we have reached the end of the block, we want to write everything, except for the last parenthesis
                            let without_last_parenthesis = without_indent
                                .chars()
                                .rev()
                                .collect::<String>()
                                .replacen(")", "", 1)
                                .chars()
                                .rev()
                                .collect::<String>();
                            write.write_all(without_last_parenthesis.as_bytes()).unwrap();
                            break;
                        }
                    }
                }
                _ => {
                    panic!("Unknown pragma: {raw_line}")
                }
            }
        } else {
            write.write_all(raw_line.as_bytes()).unwrap();
            write.write_all(b"\n").unwrap();
        }
    }
}
